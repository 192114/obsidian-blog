[{"html":"<hr>\n<p>使用  </p>\n<pre><code class=\"language-shell\">git rebase 目标基础点  \n</code></pre>\n<p><em><code>rebase</code> 是站在需要被 <code>rebase</code> 的 <code>commit</code> 上进行操作</em>  </p>\n<p><code>rebase</code> 的意思是，给你的 <code>commit</code> 序列重新设置基础点（也就是父 <code>commit</code>）。展开来说就是，把你指定的 <code>commit</code> 以及它所在的 <code>commit</code> 串，以指定的目标 <code>commit</code> 为基础，依次重新提交一次。  </p>\n<pre><code class=\"language-shell\">git checkout branch1  \ngit rebase master  \n</code></pre>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/30/1600abd620a8e28c~tplv-t2oaga2asx-jj-mark:1512:0:0:0:q75.awebp\" alt=\"\">  </p>\n<p>可以看出，通过 <code>rebase</code>，<code>5</code> 和 <code>6</code> 两条 <code>commit</code>s 把基础点从 <code>2</code> 换成了 <code>4</code> 。通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 <code>rebase</code> 的含义。  </p>\n<p>在 <code>rebase</code> 之后，记得切回 <code>master</code> 再 <code>merge</code> 一下，把 <code>master</code> 移到最新的 <code>commit</code>：  </p>\n<pre><code class=\"language-shell\">git checkout master   \n  \ngit merge branch1  \n</code></pre>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/12/2/160149e054fe485c~tplv-t2oaga2asx-jj-mark:1512:0:0:0:q75.awebp\" alt=\"\"></p>\n","tags":["git"],"date":"2024-01-04","series":"其他","title":"Git rebase(变基)","slug":"git-rebase","keywords":"git rebase","description":"git用法，git rebase","lastmod":"","share":"true"},{"html":"<hr>\n<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：  </p>\n<pre><code>$ git switch -c feature1  \nSwitched to a new branch &#39;feature1&#39;  \n</code></pre>\n<p>修改<code>readme.txt</code>最后一行，改为：  </p>\n<pre><code>Creating a new branch is quick AND simple.  \n</code></pre>\n<p>在<code>feature1</code>分支上提交：  </p>\n<pre><code>$ git add readme.txt  \n  \n$ git commit -m &quot;AND simple&quot;  \n[feature1 14096d0] AND simple  \n 1 file changed, 1 insertion(+), 1 deletion(-)  \n</code></pre>\n<p>切换到<code>master</code>分支：  </p>\n<pre><code>$ git switch master  \nSwitched to branch &#39;master&#39;  \nYour branch is ahead of &#39;origin/master&#39; by 1 commit.  \n  (use &quot;git push&quot; to publish your local commits)  \n</code></pre>\n<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。  </p>\n<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：  </p>\n<pre><code>Creating a new branch is quick &amp; simple.  \n</code></pre>\n<p>提交：  </p>\n<pre><code>$ git add readme.txt   \n$ git commit -m &quot;&amp; simple&quot;  \n[master 5dc6824] &amp; simple  \n 1 file changed, 1 insertion(+), 1 deletion(-)  \n</code></pre>\n<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：  </p>\n<pre><code class=\"language-ascii\">                            HEAD  \n                              │  \n                              │  \n                              ▼  \n                           master  \n                              │  \n                              │  \n                              ▼  \n                            ┌───┐  \n                         ┌─▶│   │  \n┌───┐    ┌───┐    ┌───┐  │  └───┘  \n│   │───▶│   │───▶│   │──┤  \n└───┘    └───┘    └───┘  │  ┌───┐  \n                         └─▶│   │  \n                            └───┘  \n                              ▲  \n                              │  \n                              │  \n                          feature1  \n</code></pre>\n<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：  </p>\n<pre><code>$ git merge feature1  \nAuto-merging readme.txt  \nCONFLICT (content): Merge conflict in readme.txt  \nAutomatic merge failed; fix conflicts and then commit the result.  \n</code></pre>\n<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：  </p>\n<pre><code>$ git status  \nOn branch master  \nYour branch is ahead of &#39;origin/master&#39; by 2 commits.  \n  (use &quot;git push&quot; to publish your local commits)  \n  \nYou have unmerged paths.  \n  (fix conflicts and run &quot;git commit&quot;)  \n  (use &quot;git merge --abort&quot; to abort the merge)  \n  \nUnmerged paths:  \n  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)  \n  \n    both modified:   readme.txt  \n  \nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)  \n</code></pre>\n<p>我们可以直接查看readme.txt的内容：  </p>\n<pre><code>Git is a distributed version control system.  \nGit is free software distributed under the GPL.  \nGit has a mutable index called stage.  \nGit tracks changes of files.  \n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  \nCreating a new branch is quick &amp; simple.  \n=======  \nCreating a new branch is quick AND simple.  \n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1  \n</code></pre>\n<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：  </p>\n<pre><code>Creating a new branch is quick and simple.  \n</code></pre>\n<p>再提交：  </p>\n<pre><code>$ git add readme.txt   \n$ git commit -m &quot;conflict fixed&quot;  \n[master cf810e4] conflict fixed  \n</code></pre>\n<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：  </p>\n<pre><code class=\"language-ascii\">                                     HEAD  \n                                       │  \n                                       │  \n                                       ▼  \n                                    master  \n                                       │  \n                                       │  \n                                       ▼  \n                            ┌───┐    ┌───┐  \n                         ┌─▶│   │───▶│   │  \n┌───┐    ┌───┐    ┌───┐  │  └───┘    └───┘  \n│   │───▶│   │───▶│   │──┤             ▲  \n└───┘    └───┘    └───┘  │  ┌───┐      │  \n                         └─▶│   │──────┘  \n                            └───┘  \n                              ▲  \n                              │  \n                              │  \n                          feature1  \n</code></pre>\n<p>用带参数的<code>git log</code>也可以看到分支的合并情况：  </p>\n<pre><code>$ git log --graph --pretty=oneline --abbrev-commit  \n*   cf810e4 (HEAD -&gt; master) conflict fixed  \n|\\    \n| * 14096d0 (feature1) AND simple  \n* | 5dc6824 &amp; simple  \n|/    \n* b17d20e branch test  \n* d46f35e (origin/master) remove test.txt  \n* b84166e add test.txt  \n* 519219b git tracks changes  \n* e43a48b understand how stage works  \n* 1094adb append GPL  \n* e475afc add distributed  \n* eaadf4e wrote a readme file  \n</code></pre>\n<p>最后，删除<code>feature1</code>分支：  </p>\n<pre><code>$ git branch -d feature1  \nDeleted branch feature1 (was 14096d0).  \n</code></pre>\n<p>用<code>git log --graph</code>命令可以看到分支合并图。  </p>\n<p><code>git merge --abort</code> 语句可以从冲突解决状态中退出, 并将文件回退到合并前的状态. 但开始合并后不能有未提交的改动.</p>\n","tags":["git"],"date":"2024-01-11","series":"其他","title":"Git冲突合并","slug":"git-merge","keywords":"git冲突合并","description":"git用法，git merge","lastmod":"","share":"true"},{"html":"<hr>\n<p>在实际开发中，我们应该按照几个基本原则进行分支管理：  </p>\n<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；  </p>\n<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；  </p>\n<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。  </p>\n<p>所以，团队合作的分支看起来就像这样：  </p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/919023260793600/0\" alt=\"git-br-policy\">  </p>\n<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。从分支历史上就可以看出分支信息  </p>\n<pre><code class=\"language-shell\">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev  \nMerge made by the &#39;recursive&#39; strategy.  \n readme.txt | 1 +  \n 1 file changed, 1 insertion(+)  \n</code></pre>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/919023225142304/0\" alt=\"git-no-ff-mode\">  </p>\n<h4>bug的处理</h4>\n<p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。  </p>\n<p>当前分支功能还没完成，这时候就需要git提供的<code>stash</code>，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。  </p>\n<pre><code class=\"language-shell\">git stash  \nSaved working directory and index state WIP on dev: f52c633 add merge  \n  \ngit checkout master # 切换需要改bug的分支  \n  \ngit checkout -b issue-1 # 创建修改bug分支  \n  \ngit commit -m &#39;fixed&#39; # 提交修改  \n  \ngit switch master # 切换到主分支  \n  \ngit merge --no-ff -m &#39;merge bug issue-1&#39; # 合并代码 （--no-ff 关闭fast-forward 生成一条merge记录）  \n  \ngit switch dev # 切换到开发分支  \n</code></pre>\n<p>用<code>git stash list</code>命令看看  </p>\n<pre><code class=\"language-shell\">git stash list  \nstash@{0}: WIP on dev: f52c633 add merge  \n</code></pre>\n<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；  </p>\n<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。  </p>\n<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。  </p>\n<p>Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支。  </p>\n<pre><code class=\"language-shell\">git branch  \n* dev  \n  master  \n$ git cherry-pick 4c805e2  \n[master 1d4b803] fix bug 101  \n 1 file changed, 1 insertion(+), 1 deletion(-)  \n</code></pre>\n<p><em><code>cherry-pick</code>和<code>git stash</code>步骤问题：</em><br>是回到dev分支后，先 git cherry-pick 4c805e2 再 git stash pop就可以了  </p>\n<h4>新特性开发</h4>\n<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。  </p>\n<p>创建新特性分支  </p>\n<pre><code class=\"language-shell\">git switch -c feature-vulcan  \nSwitched to a new branch &#39;feature-vulcan&#39;  \n</code></pre>\n<p>提交分支  </p>\n<pre><code class=\"language-shell\">git add vulcan.py  \n  \ngit status  \nOn branch feature-vulcan  \nChanges to be committed:  \n  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)  \n  \n    new file:   vulcan.py  \n  \ngit commit -m &quot;add feature vulcan&quot;  \n[feature-vulcan 287773e] add feature vulcan  \n 1 file changed, 2 insertions(+)  \n create mode 100644 vulcan.py  \n</code></pre>\n<p>切回开发分支  </p>\n<pre><code class=\"language-shell\">git switch dev  \n</code></pre>\n<p>如果一切正常，可以使用<code>git merge feature-vulcan</code>合并，如果不需要该特性就可以<code>git branch -D feature-vulcan</code> 删除该分支  </p>\n<pre><code class=\"language-shell\">git branch -d feature-vulcan  \nerror: The branch &#39;feature-vulcan&#39; is not fully merged.  \nIf you are sure you want to delete it, run &#39;git branch -D feature-vulcan&#39;.  \n</code></pre>\n<p><code>-D</code> 是强制删除，使用<code>-d</code>则是给出提示当前分支未合并，不能删除。  </p>\n<h4>团队协作</h4>\n<ul>\n<li>查看远程库信息，使用<code>git remote -v</code>；  </li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；  </li>\n<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；  </li>\n<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；  </li>\n<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；  </li>\n<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>\n</ul>\n<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。  </p>\n<p>要查看远程库的信息，用<code>git remote</code>：  </p>\n<pre><code class=\"language-shell\">git remote  \norigin  \n</code></pre>\n<p>或者，用<code>git remote -v</code>显示更详细的信息：  </p>\n<pre><code class=\"language-shell\">git remote -v  \norigin  git@github.com:michaelliao/learngit.git (fetch)  \norigin  git@github.com:michaelliao/learngit.git (push)  \n</code></pre>\n<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。  </p>\n<p>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。  </p>\n<pre><code class=\"language-shell\">git push origin dev # 推送到dev分支  \n  \ngit push origin master # 推送到住分支  \n</code></pre>\n<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？  </p>\n<ul>\n<li><code>master</code>分支是主分支，因此要时刻与远程同步；  </li>\n<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；  </li>\n<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；  </li>\n<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>\n</ul>\n<h4>抓取分支</h4>\n<p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。  </p>\n<pre><code class=\"language-shell\">git clone git@github.com:michaelliao/learngit.git  \nCloning into &#39;learngit&#39;...  \nremote: Counting objects: 40, done.  \nremote: Compressing objects: 100% (21/21), done.  \nremote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0  \nReceiving objects: 100% (40/40), done.  \nResolving deltas: 100% (14/14), done.  \n</code></pre>\n<p>从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支  </p>\n<p>要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：  </p>\n<pre><code>$ git checkout -b dev origin/dev  \n</code></pre>\n<p>现在，就可以在<code>dev</code>上继续修改，然后，把<code>dev</code>分支<code>push</code>到远程：  </p>\n<pre><code class=\"language-shell\">$ git push origin dev  \nCounting objects: 3, done.  \nDelta compression using up to 4 threads.  \nCompressing objects: 100% (2/2), done.  \nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.  \nTotal 3 (delta 0), reused 0 (delta 0)  \nTo github.com:michaelliao/learngit.git  \n   f52c633..7a5e5dd  dev -&gt; dev  \n</code></pre>\n<p>多人协作的工作模式通常是这样：  </p>\n<ol>\n<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；  </li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；  </li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；  </li>\n<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>\n</ol>\n<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>\n","tags":["git"],"date":"2024-01-19","series":"其他","title":"Git分支策略","slug":"git-branch-strategy","keywords":"git branch strategy","description":"git用法，git 分支策略","lastmod":"","share":"true"},{"html":"<hr>\n<ul>\n<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；  </li>\n<li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；  </li>\n<li>命令<code>git tag</code>可以查看所有标签。  </li>\n<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；  </li>\n<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；  </li>\n<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；  </li>\n<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。  </li>\n<li><em>命令<code>git push origin -d tag tagName</code>也可以用来删除一个远程分支</em></li>\n</ul>\n<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。  </p>\n<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。  </p>\n<pre><code class=\"language-shell\">git tag v1.0 # 打标签  \n</code></pre>\n<pre><code class=\"language-shell\">git tag v0.9 f52c633  \n</code></pre>\n<pre><code class=\"language-shell\">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb  \n</code></pre>\n<p>查看某个标签的详细信息 <code>git show &lt;tagname&gt;</code>  </p>\n<pre><code class=\"language-shell\">git show v0.9  \ncommit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)  \nAuthor: Michael Liao &lt;askxuefeng@gmail.com&gt;  \nDate:   Fri May 18 21:56:54 2018 +0800  \n  \n    add merge  \n  \ndiff --git a/readme.txt b/readme.txt  \n...  \n</code></pre>\n<p>查看标签  </p>\n<pre><code class=\"language-shell\">git tag  \nv1.0  \n</code></pre>\n<p>删除标签  </p>\n<pre><code class=\"language-shell\">git tag -d v0.1  \nDeleted tag &#39;v0.1&#39; (was f15b0dd)  \n</code></pre>\n<p>推送某个标签到远程  </p>\n<pre><code class=\"language-shell\">git push origin v1.0  \nTotal 0 (delta 0), reused 0 (delta 0)  \nTo github.com:michaelliao/learngit.git  \n * [new tag]         v1.0 -&gt; v1.0  \n</code></pre>\n<p>推送全部标签到远程  </p>\n<pre><code class=\"language-shell\">git push origin --tags  \nTotal 0 (delta 0), reused 0 (delta 0)  \nTo github.com:michaelliao/learngit.git  \n * [new tag]         v0.9 -&gt; v0.9  \n</code></pre>\n<p>远程标签的删除（标签名和分支名不同名的情况）  </p>\n<p>前提是先删除本地的tag <code>git tag -d v1.0</code>  </p>\n<pre><code class=\"language-shell\">git push --delete origin prod1.0  \n  \nTo https://github.com/myrepos/prod.git  \n - [deleted]         prod1.0  \n</code></pre>\n<p>也可以用  </p>\n<pre><code class=\"language-shell\">git push origin :refs/tags/prod1.0  \n  \nTo https://github.com/myrepos/prod.git  \n - [deleted]         prod1.0  \n</code></pre>\n","tags":["git"],"date":"2024-01-08","series":"其他","title":"Git 标签","slug":"git-tag","keywords":"git tag","description":"git用法，git tag","lastmod":"","share":"true"},{"html":"<hr>\n<ul>\n<li>查看分支：<code>git branch</code>  </li>\n<li>创建分支：<code>git branch &lt;name&gt;</code>  </li>\n<li>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code>  </li>\n<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code>  </li>\n<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code>  </li>\n<li>删除分支：<code>git branch -d &lt;name&gt;</code></li>\n</ul>\n<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：  </p>\n<pre><code class=\"language-ascii\">                  HEAD  \n                    │  \n                    │  \n                    ▼  \n                 master  \n                    │  \n                    │  \n                    ▼  \n┌───┐    ┌───┐    ┌───┐  \n│   │───▶│   │───▶│   │  \n└───┘    └───┘    └───┘  \n</code></pre>\n<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。  </p>\n<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：  </p>\n<pre><code class=\"language-ascii\">                 master  \n                    │  \n                    │  \n                    ▼  \n┌───┐    ┌───┐    ┌───┐  \n│   │───▶│   │───▶│   │  \n└───┘    └───┘    └───┘  \n                    ▲  \n                    │  \n                    │  \n                   dev  \n                    ▲  \n                    │  \n                    │  \n                  HEAD  \n</code></pre>\n<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！  </p>\n<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：  </p>\n<pre><code class=\"language-ascii\">                 master  \n                    │  \n                    │  \n                    ▼  \n┌───┐    ┌───┐    ┌───┐    ┌───┐  \n│   │───▶│   │───▶│   │───▶│   │  \n└───┘    └───┘    └───┘    └───┘  \n                             ▲  \n                             │  \n                             │  \n                            dev  \n                             ▲  \n                             │  \n                             │  \n                           HEAD  \n</code></pre>\n<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：  </p>\n<pre><code class=\"language-ascii\">                           HEAD  \n                             │  \n                             │  \n                             ▼  \n                          master  \n                             │  \n                             │  \n                             ▼  \n┌───┐    ┌───┐    ┌───┐    ┌───┐  \n│   │───▶│   │───▶│   │───▶│   │  \n└───┘    └───┘    └───┘    └───┘  \n                             ▲  \n                             │  \n                             │  \n                            dev  \n</code></pre>\n<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！  </p>\n<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：  </p>\n<pre><code class=\"language-ascii\">                           HEAD  \n                             │  \n                             │  \n                             ▼  \n                          master  \n                             │  \n                             │  \n                             ▼  \n┌───┐    ┌───┐    ┌───┐    ┌───┐  \n│   │───▶│   │───▶│   │───▶│   │  \n└───┘    └───┘    └───┘    └───┘  \n</code></pre>\n<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？  </p>\n<p>下面开始实战。  </p>\n<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：  </p>\n<pre><code>$ git checkout -b dev  \nSwitched to a new branch &#39;dev&#39;  \n</code></pre>\n<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：  </p>\n<pre><code>$ git branch dev  \n$ git checkout dev  \nSwitched to branch &#39;dev&#39;  \n</code></pre>\n<p>然后，用<code>git branch</code>命令查看当前分支：  </p>\n<pre><code>$ git branch  \n* dev  \n  master  \n</code></pre>\n<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。  </p>\n<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：  </p>\n<pre><code>Creating a new branch is quick.  \n</code></pre>\n<p>然后提交：  </p>\n<pre><code>$ git add readme.txt   \n$ git commit -m &quot;branch test&quot;  \n[dev b17d20e] branch test  \n 1 file changed, 1 insertion(+)  \n</code></pre>\n<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：  </p>\n<pre><code>$ git checkout master  \nSwitched to branch &#39;master&#39;  \n</code></pre>\n<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：  </p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/919022533080576/0\" alt=\"git-br-on-master\">  </p>\n<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：  </p>\n<pre><code>$ git merge dev  \nUpdating d46f35e..b17d20e  \nFast-forward  \n readme.txt | 1 +  \n 1 file changed, 1 insertion(+)  \n</code></pre>\n<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。  </p>\n<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。  </p>\n<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。  </p>\n<p>合并完成后，就可以放心地删除<code>dev</code>分支了：  </p>\n<pre><code>$ git branch -d dev  \nDeleted branch dev (was b17d20e).  \n</code></pre>\n<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：  </p>\n<pre><code>$ git branch  \n* master  \n</code></pre>\n<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。  </p>\n<h3>switch</h3>\n<p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。  </p>\n<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：  </p>\n<p>创建并切换到新的<code>dev</code>分支，可以使用：  </p>\n<pre><code>$ git switch -c dev  \n</code></pre>\n<p>直接切换到已有的<code>master</code>分支，可以使用：  </p>\n<pre><code>$ git switch master  \n</code></pre>\n<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>\n","tags":["git"],"date":"2024-01-08","series":"其他","title":"Git的分支管理","slug":"git-branch","keywords":"git branch","description":"git用法，git branch","lastmod":"","share":"true"},{"html":"<hr>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰老师的git教程</a>  </p>\n<ul>\n<li><code>git init</code> 初始化仓库  </li>\n<li><code>git add [file1 file2] / .</code> 添加到暂存区  </li>\n<li><code>git commit -m [message]</code> 将当前staged修改提交<code>--amend</code>就会生成一条新的commit替换了原commit  </li>\n<li><code>git status</code> 查看状态</li>\n</ul>\n<pre><code class=\"language-shell\">git status  \nOn branch master  \nChanges not staged for commit:  \n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  \n  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)  \n  \n    modified:   readme.txt  \n  \nUntracked files:  \n  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)  \n  \n    LICENSE  \n  \nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)  \n</code></pre>\n<ul>\n<li><code>git log</code> 查看历史记录 <code>--pretty=oneline</code> 加上他一行展示信息</li>\n</ul>\n<pre><code class=\"language-shell\">git log  \ncommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)  \nAuthor: Michael Liao &lt;askxuefeng@gmail.com&gt;  \nDate:   Fri May 18 21:03:36 2018 +0800  \n  \n    add distributed  \n  \ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0  \nAuthor: Michael Liao &lt;askxuefeng@gmail.com&gt;  \nDate:   Fri May 18 20:59:18 2018 +0800  \n  \n    wrote a readme file  \n</code></pre>\n<ul>\n<li><code>git reflog</code> 记录你的每一次命令</li>\n</ul>\n<pre><code class=\"language-shell\">git reflog  \n  \ne475afc HEAD@{1}: reset: moving to HEAD^  \n1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL  \ne475afc HEAD@{3}: commit: add distributed  \neaadf4e HEAD@{4}: commit (initial): wrote a readme file  \n</code></pre>\n<ul>\n<li><code>git diff</code> 比对改动</li>\n</ul>\n<pre><code class=\"language-shell\">git diff readme.txt   \ndiff --git a/readme.txt b/readme.txt  \nindex 46d49bf..9247db6 100644  \n--- a/readme.txt  \n+++ b/readme.txt  \n@@ -1,2 +1,2 @@  \n-Git is a version control system.  \n+Git is a distributed version control system.  \n Git is free software.  \n</code></pre>\n<h4>回退版本</h4>\n<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。  </p>\n<ul>\n<li><code>git reset --hard HEAD^</code> 回退到上一个版本   </li>\n<li><code>git reset --hard commitId</code> 回退到指定commit，说重置应该更为准确</li>\n</ul>\n<h4>撤销修改</h4>\n<pre><code class=\"language-shell\">git checkout -- readme.txt  \n</code></pre>\n<p>命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：  </p>\n<ul>\n<li><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；  </p>\n</li>\n<li><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>\n</li>\n</ul>\n<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。  </p>\n<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。  </p>\n<p>如果已经<code>git add</code>到暂存区了，需要先执行<code>git reset --hard HEAD file</code>将文件修改撤销掉（unstage）之后在执行 <code>git checkout -- file</code>  </p>\n<p>撤销操作汇总：  </p>\n<ul>\n<li>情况1：<strong>文件只在工作区操作，未add</strong>。撤销操作：<code>git restore &lt;file&gt;</code>。结果：工作区文件回退*。  </li>\n<li>情况2：<strong>文件已add，未commit</strong>。撤销操作：<code>git restore --staged &lt;file&gt;</code>。结果：<strong>暂存区文件回退，工作区文件未回退，如需继续回退，操按情况1操作。</strong>  </li>\n<li>情况3：<strong>文件已add，已commit</strong>。撤销操作：<strong>git reset --hard commit_id</strong>。结果：<strong>工作区文件、暂存区文件、本地仓库都回退</strong></li>\n</ul>\n<h4>远程仓库配置</h4>\n<h5>生成公钥私钥</h5>\n<pre><code class=\"language-shell\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  \n</code></pre>\n<p>用户目录下的<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。  </p>\n<p>登录github，“Account settings”，“SSH Keys”页面将公钥配置到gitbub中  </p>\n<p>将本地仓库关联远程仓库  </p>\n<pre><code class=\"language-shell\">git remote add origin git@github.com:192114/git-practice.git  \n</code></pre>\n<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。  </p>\n<pre><code class=\"language-shell\">git push -u origin master  \nCounting objects: 20, done.  \nDelta compression using up to 4 threads.  \nCompressing objects: 100% (15/15), done.  \nWriting objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.  \nTotal 20 (delta 5), reused 0 (delta 0)  \nremote: Resolving deltas: 100% (5/5), done.  \nTo github.com:michaelliao/learngit.git  \n * [new branch]      master -&gt; master  \nBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.  \n</code></pre>\n<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。  </p>\n<h5>删除远程库</h5>\n<pre><code class=\"language-shell\">git remote -v  \norigin  git@github.com:192114/git-practice.git (fetch)  \norigin  git@github.com:192114/git-practice.git (push)  \n</code></pre>\n<pre><code class=\"language-shell\">git remote rm origin  \n</code></pre>\n<h5>从远端克隆</h5>\n<pre><code class=\"language-shell\">git clone git@github.com:192114/gitskills.git  \nCloning into &#39;gitskills&#39;...  \nremote: Counting objects: 3, done.  \nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3  \nReceiving objects: 100% (3/3), done.  \n</code></pre>\n","tags":["git"],"date":"2024-12-25","series":"其他","title":"Git的基本用法","slug":"git-usage","keywords":"git基本用法","description":"git用法，git 基础用法","lastmod":"","share":"true"},{"html":"<hr>\n<h3>插件</h3>\n<ul>\n<li>better-comments 高亮注释  </li>\n<li>vscode-tailwindcss tailwindcss 语法提示  </li>\n<li>codeium AI代码提示  </li>\n<li>vscode-eslint eslint语法校验  </li>\n<li>prettier-vscode prettier 代码格式化  </li>\n<li>todo-tree 记录todo标识   </li>\n<li>git-graph git图形化显示提交信息  </li>\n<li>vscode-language-pack-zh-hans 编辑器中文  </li>\n<li>svg-preview svg 预览  </li>\n<li>vscode-stylelint css 语法校验  </li>\n<li>vscode-icons 图标  </li>\n<li>volar vue 语法支持  </li>\n<li>vscode-typescript-vue-plugin vue typescript 支持  </li>\n<li>material-theme 编辑器主题</li>\n</ul>\n<h3>配置</h3>\n<pre><code class=\"language-json\">{  \n  &quot;workbench.colorTheme&quot;: &quot;One Dark Pro Mix&quot;,  \n  &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,  \n  &quot;editor.fontSize&quot;: 18,  \n  &quot;editor.fontFamily&quot;: &quot;&#39;Hack Nerd Font Mono&#39;, Menlo, Monaco, &#39;Courier New&#39;, monospace&quot;,  \n  &quot;editor.tabSize&quot;: 2,  \n  &quot;editor.guides.bracketPairs&quot;: true,  \n  &quot;editor.guides.bracketPairsHorizontal&quot;: true,  \n  &quot;editor.wordWrap&quot;: &quot;on&quot;,  \n  &quot;editor.wordWrapColumn&quot;: 100,  \n  &quot;workbench.startupEditor&quot;: &quot;none&quot;,  \n  &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;,  \n  &quot;[typescriptreact]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;[typescript]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;[javascript]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;[css]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;editor.fontLigatures&quot;: true,  \n  &quot;[jsonc]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;[json]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;[html]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;vscode.html-language-features&quot;  \n  },  \n  &quot;[javascriptreact]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;typescript.inlayHints.parameterNames.enabled&quot;: &quot;all&quot;,  \n  &quot;typescript.inlayHints.parameterTypes.enabled&quot;: true,  \n  &quot;[vue]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;[scss]&quot;: {  \n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  \n  },  \n  &quot;codeium.enableConfig&quot;: {  \n    &quot;*&quot;: true,  \n    &quot;xml&quot;: true,  \n    &quot;plaintext&quot;: true  \n  },  \n  &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;PowerShell&quot;,  \n  &quot;git.suggestSmartCommit&quot;: false,  \n  &quot;terminal.integrated.fontFamily&quot;: &quot;&#39;Hack Nerd Font Mono&#39;, monospace&quot;,  \n  &quot;terminal.integrated.env.linux&quot;: {},  \n  &quot;window.restoreFullscreen&quot;: true,  \n  &quot;workbench.tree.indent&quot;: 16,  \n    \n  &quot;audioCues.diffLineDeleted&quot;: &quot;off&quot;,  \n  &quot;audioCues.chatResponsePending&quot;: &quot;off&quot;,  \n  &quot;audioCues.diffLineInserted&quot;: &quot;off&quot;,  \n  &quot;audioCues.diffLineModified&quot;: &quot;off&quot;,  \n  &quot;audioCues.lineHasBreakpoint&quot;: &quot;off&quot;,  \n  &quot;audioCues.lineHasError&quot;: &quot;off&quot;,  \n  &quot;audioCues.lineHasFoldedArea&quot;: &quot;off&quot;,  \n  &quot;audioCues.lineHasInlineSuggestion&quot;: &quot;off&quot;,  \n  &quot;audioCues.noInlayHints&quot;: &quot;off&quot;,  \n  &quot;audioCues.notebookCellCompleted&quot;: &quot;off&quot;,  \n  &quot;audioCues.notebookCellFailed&quot;: &quot;off&quot;,  \n  &quot;audioCues.onDebugBreak&quot;: &quot;off&quot;,  \n  &quot;audioCues.taskCompleted&quot;: &quot;off&quot;,  \n  &quot;audioCues.taskFailed&quot;: &quot;off&quot;,  \n  &quot;audioCues.terminalCommandFailed&quot;: &quot;off&quot;,  \n  &quot;audioCues.terminalQuickFix&quot;: &quot;off&quot;,  \n  &quot;audioCues.volume&quot;: 0,  \n  &quot;accessibility.alert.format&quot;: &quot;never&quot;,  \n  &quot;accessibility.alert.save&quot;: &quot;never&quot;  \n}  \n  \n</code></pre>\n<p><em>可打开编辑器的同步功能，直接同步自己的配置</em></p>\n","tags":["computer"],"date":"2024-12-17","series":"Mac装机","title":"VS Code 配置","slug":"vscode-config","keywords":"Vscode","description":"Vscode配置，Vscode插件","lastmod":"","share":"true"},{"html":"<hr>\n<h5>安装 <a href=\"https://brew.sh/\">Homebrew</a></h5>\n<pre><code class=\"language-shell\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;  \n</code></pre>\n<h5>配置zsh（使用mac terminal）</h5>\n<pre><code class=\"language-shell\"># ~/.zshenv  \n// 将homebrew写入环境变量  \neval &quot;$(/usr/local/bin/brew shellenv)&quot;  \n  \n# 快捷的cd命令 启发与z autojump  \neval &quot;$(zoxide init zsh --cmd cd)&quot;  \n  \n</code></pre>\n<p>zsh常见配置文件  </p>\n<ol>\n<li>.zshenv 通常放环境变量 任何时候都会被加载  </li>\n<li>.zshrc 交互式终端可用<br>加载顺序：<code>.zshenv </code>-&gt; <code>.zprofile</code> if login -&gt;<code> .zshrc</code> if interactive -&gt; <code>.zlogin</code> if login -&gt; <code>.zlogout</code></li>\n</ol>\n<h5>zsh插件管理 <a href=\"https://github.com/zdharma-continuum/zinit#manual\">zinit</a></h5>\n<pre><code class=\"language-shell\"> brew install zinit  \n</code></pre>\n<pre><code class=\"language-shell\"># .zshrc file  \n### Added by Zinit&#39;s installer  \n  \nsource &quot;/usr/local/opt/zinit/zinit.zsh&quot;  \n  \nautoload -Uz _zinit  \n  \n(( ${+_comps} )) &amp;&amp; _comps[zinit]=_zinit  \n  \n### End of Zinit&#39;s installer chunk  \n  \n# pure 主题  \n  \nzinit ice compile&#39;(pure|async).zsh&#39; pick&#39;async.zsh&#39; src&#39;pure.zsh&#39;  \n  \nzinit light sindresorhus/pure  \n  \n# 语法高亮  \n  \nzinit ice lucid wait=&#39;0&#39; atinit=&#39;zpcompinit&#39;  \n  \nzinit light zdharma-continuum/fast-syntax-highlighting  \n  \n...  \n</code></pre>\n<p>zinit 语法说明  </p>\n<ul>\n<li><code>zinit light &lt;repo/plugin&gt;</code> 加载插件 不追踪插件行为  </li>\n<li><code>zinit load &lt;repo/plugin&gt;</code> 加载插件 可用unload卸载 追踪插件行为 查看报告 卸载  </li>\n<li><code>zinit snippet URL</code> 加载本地或远程文件  </li>\n<li><code>zinit self-update</code> 自更新  </li>\n<li><code>zinit update --parallel number</code>更新插件  </li>\n<li><code>zinit ice wait=&quot;0&quot;</code> 等待0s  <strong>ice</strong>选项 表示只使用一次 对下一条命令起作用 <strong>pick</strong> 正则匹配第一个符合条件的文件 <strong>src</strong> 指定source的文件 <strong>atinit</strong> 在加载插件时需要执行的命令</li>\n</ul>\n<h5>插件</h5>\n<ul>\n<li><a href=\"https://github.com/zdharma-continuum/fast-syntax-highlighting\">zdharma-continuum/fast-syntax-highlighting</a> 语法高亮  </li>\n<li><a href=\"https://github.com/zdharma-continuum/history-search-multi-word\"> zdharma-continuum/history-search-multi-word</a> <code>ctrl+r</code> 选择输入匹配的语法  </li>\n<li><a href=\"https://github.com/zsh-users/zsh-completions\">zsh-users/zsh-completions</a> 补全 zsh 语法  </li>\n<li><a href=\"https://github.com/zsh-users/zsh-autosuggestions\">zsh-users/zsh-autosuggestions</a> 建议 提示之前的输入值  </li>\n<li><a href=\"https://github.com/eza-community/eza\">eza</a> 更好的ls 命令</li>\n</ul>\n<pre><code class=\"language-shell\">brew install eza  \n# ~/.zshrc  \n# eza 别名  \n  \n# 带图标  \n  \nalias ls=&quot;eza --icons&quot;  \n  \n# 文件详情  \n  \nalias ll=&quot;eza --icons --long --header&quot;  \n  \n# 文件详情 包含隐藏文件  \n  \nalias la=&quot;eza --icons --long --header --all&quot;  \n  \n# 显示文件详情并带git信息  \n  \nalias lg=&quot;eza --icons --long --header --all --git&quot;  \n  \n# 关闭默认ls颜色  \n  \nDISABLE_LS_COLORS=true   \n  \n</code></pre>\n<ul>\n<li><a href=\"https://github.com/sharkdp/bat/blob/master/doc/README-zh.md\">bat</a> 类似cat 但有语法高亮</li>\n</ul>\n<pre><code class=\"language-shell\">brew install bat  \n  \n#命令  \nbat /example/z.js -r 16 #显示文件 从第16行显示  \n  \n# ~/.config/bat.conf  \n--paging=never #不分页  \n--theme=&quot;Solarized (dark)&quot; # 主题  \n  \n# `bat --list-themes` 一份语法高亮主题的清单  \n</code></pre>\n<ul>\n<li><a href=\"https://github.com/BurntSushi/ripgrep\">ripgrep</a> 命令行搜索工具</li>\n</ul>\n<pre><code class=\"language-shell\">brew install ripgrep  \n  \n#命令  \nrg const demo.js # 在demo.js 搜索const关键字  \nrg const\\w+ demo.js # 正则匹配内容  \n  \n# ~/.config/ripgrep.conf  \n #Don&#39;t let ripgrep vomit really long lines to my terminal, and show a preview.  \n--max-columns=150  \n--max-columns-preview   \n  \n# Add my &#39;web&#39; type.  \n--type-add  \nweb:*.{html,css,js}*   \n  \n# Search hidden files / directories (e.g. dotfiles) by default  \n--hidden    \n  \n# Using glob patterns to include/exclude files or folders  \n--glob=!.git/*  \n  \n# or  \n--glob  \n!.git/*   \n  \n# Set the colors.  \n--colors=line:none  \n--colors=line:style:bold  \n  \n# Because who cares about case!?  \n--smart-case  \n</code></pre>\n<h5>修改terminal主题配色</h5>\n<ol>\n<li>左上角终端选偏好设置  </li>\n<li>点击描述文件  </li>\n<li><a href=\"https://github.com/lysyi3m/macos-terminal-themes\">themes</a>下载主题  </li>\n<li>导入下载的主题  </li>\n<li>点击使用主题</li>\n</ol>\n<h5>安装字体</h5>\n<pre><code class=\"language-shell\">brew tap homebrew/cask-fonts  \nbrew install font-hack-nerd-font  \n</code></pre>\n<ul>\n<li>terminal 描述文件 文本处切换字体   </li>\n<li>vscode fontfamily 配置 字体 &#39;Hack Nerd Font Mono&#39; （terminal设置字体同理）</li>\n</ul>\n<h5>完整.zshrc</h5>\n<pre><code class=\"language-shell\">### Added by Zinit&#39;s installer  \nsource &quot;/usr/local/opt/zinit/zinit.zsh&quot;  \nautoload -Uz _zinit  \n(( ${+_comps} )) &amp;&amp; _comps[zinit]=_zinit  \n### End of Zinit&#39;s installer chunk  \n  \n# pure 主题  \nzinit ice compile&#39;(pure|async).zsh&#39; pick&#39;async.zsh&#39; src&#39;pure.zsh&#39;  \nzinit light sindresorhus/pure  \n  \n# 语法高亮  \nzinit ice lucid wait=&#39;0&#39; atinit=&#39;zpcompinit&#39;  \nzinit light zdharma-continuum/fast-syntax-highlighting  \n  \n# 搜索历史输入  \nzinit ice lucid wait=&#39;0&#39;  \nzinit light zdharma-continuum/history-search-multi-word  \n  \n# 补全  \nzinit ice lucid wait=&#39;0&#39;  \nzinit light zsh-users/zsh-completions  \n  \n# 自动建议  \nzinit ice wait lucid atload&#39;_zsh_autosuggest_start&#39;  \nzinit light zsh-users/zsh-autosuggestions  \n  \n# 加载 OMZ 框架及部分插件  \nzinit snippet OMZ::lib/completion.zsh  \nzinit snippet OMZ::lib/history.zsh  \nzinit snippet OMZ::lib/key-bindings.zsh  \nzinit snippet OMZ::lib/theme-and-appearance.zsh  \nzinit snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh  \nzinit snippet OMZ::plugins/sudo/sudo.plugin.zsh  \nzinit snippet OMZ::plugins/extract  \n    \nzinit ice lucid wait=&#39;1&#39;  \nzinit snippet OMZ::plugins/git/git.plugin.zsh  \n  \n# alias 代理命令  \nalias proxy=&quot;export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087;export ALL_PROXY=socks5://127.0.0.1:1080&quot;  \nalias unproxy=&quot;unset https_proxy http_proxy all_proxy&quot;  \n  \n# eza 别名  \n# 带图标  \nalias ls=&quot;eza --icons&quot;  \n# 文件详情  \nalias ll=&quot;eza --icons --long --header&quot;  \n# 文件详情 包含隐藏文件  \nalias la=&quot;eza --icons --long --header --all&quot;  \n# 显示文件详情并带git信息  \nalias lg=&quot;eza --icons --long --header --all --git&quot;  \n# 关闭默认ls颜色  \nDISABLE_LS_COLORS=true  \n    \n# 快捷清屏  \nalias cls=clear  \n  \n# volta 环境变量  \nexport VOLTA_HOME=&quot;$HOME/.volta&quot;  \nexport PATH=&quot;$VOLTA_HOME/bin:$PATH&quot;  \n  \n# bat 配置文件路径  \nexport BAT_CONFIG_PATH=&quot;$HOME/.config/bat.conf&quot;  \n  \n# ripgrep 配置文件路径  \nexport RIPGREP_CONFIG_PATH=&quot;$HOME/.config/ripgrep.conf&quot;  \n</code></pre>\n","tags":["computer"],"date":"2024-12-16","series":"Mac装机","title":"装机指南 - Terminal zsh 配置","slug":"mac-terminal","keywords":"mac装机","description":"mac装机，terminal，zsh，volta","lastmod":"","share":"true"},{"html":"<hr>\n<h4><a href=\"https://github.com/volta-cli/volta\">VOLTA</a> - javascript 工具链管理工具 主要用于node版本管理</h4>\n<ol>\n<li>安装</li>\n</ol>\n<pre><code class=\"language-shell\">brew install   \n</code></pre>\n<ol start=\"2\">\n<li>配置环境变量</li>\n</ol>\n<pre><code class=\"language-shell\"># ~/.zshrc  \n...  \nexport VOLTA_HOME=&quot;$HOME/.volta&quot;  \nexport PATH=&quot;$VOLTA_HOME/bin:$PATH&quot;  \n...  \n</code></pre>\n<ol start=\"3\">\n<li>常用命令</li>\n</ol>\n<pre><code class=\"language-shell\">volta install node # 安装最新版的node  \nvolta install node@version # 安装指定版本的node  \n  \nvolta uninstall node@version # 卸载  \n  \nvolta pin node@12.20.2 # 指定项目使用node的版本  \nvolta pin yarn@1.19.2  \n# 会在package.json里添加  \n&quot;volta&quot;: {  \n  &quot;node&quot;: &quot;12.20.2&quot;,  \n  &quot;yarn&quot;: &quot;1.19.2&quot;  \n}  \n  \n</code></pre>\n<p><em>关注node的试验特性（包管理器的管理器） -  Corepack</em>  </p>\n<h4>必备软件</h4>\n<ol>\n<li>vs code 编辑器  </li>\n<li>chrome 浏览器  </li>\n<li>inna 视频播放器  </li>\n<li>maccy 剪切板工具   </li>\n<li>obsidian 笔记工具  </li>\n<li>The Unarchiver 解压缩工具</li>\n</ol>\n","tags":["computer"],"date":"2024-12-15","series":"Mac装机","title":"装机指南 - 前端开发环境","slug":"mac-frontend","keywords":"mac装机","description":"mac装机，前端，brew","lastmod":"","share":"true"}]