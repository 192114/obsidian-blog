{"html":"<hr>\n<h3 id=\"anchor-斐波那契算法介绍\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-斐波那契算法介绍\"><span class=\"octicon octicon-link\"></span></a>\n        斐波那契算法介绍\n        </h3>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0\">斐波那契数</a>&nbsp;序列有这样的公式：&nbsp;<code>Fn&nbsp;= Fn-1&nbsp;+ Fn-2</code>。换句话说，下一个数字是前两个数字的和。<br>前两个数字是&nbsp;<code>1</code>，然后是&nbsp;<code>2(1+1)</code>，然后&nbsp;<code>3(1+2)</code>，<code>5(2+3)</code>&nbsp;等：<code>1, 1, 2, 3, 5, 8, 13, 21...</code>。  </p>\n<h3 id=\"anchor-算法实现\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-算法实现\"><span class=\"octicon octicon-link\"></span></a>\n        算法实现\n        </h3>\n<h4 id=\"anchor-普通递归\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-普通递归\"><span class=\"octicon octicon-link\"></span></a>\n        普通递归\n        </h4>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-params\">num</span>) {  \n  <span class=\"hljs-keyword\">if</span> (num &lt;= <span class=\"hljs-number\">2</span>) {  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>  \n  } <span class=\"hljs-keyword\">else</span> {  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fib</span>(num-<span class=\"hljs-number\">2</span>) + <span class=\"hljs-title function_\">fib</span>(num-<span class=\"hljs-number\">1</span>)  \n  }  \n}  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">7</span>)) <span class=\"hljs-comment\">// ==&gt; 13  </span>\n<span class=\"hljs-comment\">// console.log(fib(77)) // 5527939700884757 ==&gt; 超级慢 涉及到很多的重复计算  </span>\n</code></pre><p>该方法有一个很大的问题就是<em>重复计算</em>，比如：  </p>\n<pre><code class=\"hljs language-javascript\">...  \n<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">5</span>) = <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">4</span>) + <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">3</span>)  \n<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">6</span>) = <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">5</span>) + <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">4</span>)  \n...  \n</code></pre><p>这是完整的递归树示例：<br><img alt=\"Pasted image 20240313163059.png\" src=\"../../static/images/Pasted%20image%2020240313163059.png\"><br>我们可以清除的发现 <code>fib(3)</code> 被调用了 2 次，<code>fib(2)</code> 调用了 3 次。如果总数越大重复调用就越多。  </p>\n<h4 id=\"anchor-缓存计算结果优化的方法\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-缓存计算结果优化的方法\"><span class=\"octicon octicon-link\"></span></a>\n        缓存计算结果优化的方法\n        </h4>\n<p>通过缓存之前出现的计算结果，减少计算的数量，达到优化的目的。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fibOptimization</span> (n) {  \n    \n  <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">2</span>) {  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>  \n  } <span class=\"hljs-keyword\">else</span> {  \n    <span class=\"hljs-keyword\">const</span> cache1 = map.<span class=\"hljs-title function_\">get</span>(n - <span class=\"hljs-number\">1</span>)  \n    <span class=\"hljs-keyword\">const</span> cache2 = map.<span class=\"hljs-title function_\">get</span>(n - <span class=\"hljs-number\">2</span>)  \n    <span class=\"hljs-keyword\">let</span> a  \n    <span class=\"hljs-keyword\">let</span> b  \n    <span class=\"hljs-keyword\">if</span> (cache1) {  \n      a = cache1  \n    } <span class=\"hljs-keyword\">else</span> {  \n      a = <span class=\"hljs-title function_\">fibOptimization</span>(n - <span class=\"hljs-number\">1</span>)  \n      map.<span class=\"hljs-title function_\">set</span>(n - <span class=\"hljs-number\">1</span>, a)  \n    }  \n  \n    <span class=\"hljs-keyword\">if</span> (cache2) {  \n      b = cache2  \n    } <span class=\"hljs-keyword\">else</span> {  \n      b = <span class=\"hljs-title function_\">fibOptimization</span>(n - <span class=\"hljs-number\">2</span>)  \n      map.<span class=\"hljs-title function_\">set</span>(n - <span class=\"hljs-number\">2</span>, b)  \n    }  \n      \n    <span class=\"hljs-keyword\">return</span> a + b  \n  }  \n}  \n  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fibOptimization</span>(<span class=\"hljs-number\">77</span>))  \n</code></pre><h4 id=\"anchor-自下而上的动态规划\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-自下而上的动态规划\"><span class=\"octicon octicon-link\"></span></a>\n        自下而上的动态规划\n        </h4>\n<p><strong>动态规划（Dynamic Programming）</strong> 是一种解决问题的数学方法，常用于优化问题。在计算机科学中，动态规划通过将问题分解为子问题，并存储子问题的解来避免重复计算，从而提高算法的效率。  </p>\n<p><strong>自下而上</strong>是通过&nbsp;<strong>迭代</strong>&nbsp;实现的，先从子问题开始计算，重复计算推算出问题的解。  </p>\n<p>分析过程：<br>根据斐波那契数的计算规则，数值小于等于 2 的时候返回的是 1，之后是它前两个数的和，传入数值小于 3 的时候不用执行循环，故循环的起始值从 3 开始即可。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// a = fib(1), b = fib(2)，这些值是根据定义 1 得到的  </span>\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">1</span>;  \n  \n<span class=\"hljs-comment\">// 求两者的和得到 c = fib(3)  </span>\n<span class=\"hljs-keyword\">let</span> c = a + b;  \n  \n<span class=\"hljs-comment\">/* 现在我们有 fib(1)，fib(2) 和 fib(3)  \na  b  c  \n1, 1, 2  \n*/</span>  \n</code></pre><p>计算 <code>fib(4)=fib(3)+fib(2)</code>，我们就将变量 <code>a,b</code> 移动得到 <code>fib(2),fib(3)</code>，<code>c</code>&nbsp;将得到两者的和  </p>\n<pre><code class=\"hljs language-javascript\">a = b; <span class=\"hljs-comment\">// 现在 a = fib(2)  </span>\nb = c; <span class=\"hljs-comment\">// 现在 b = fib(3)  </span>\nc = a + b; <span class=\"hljs-comment\">// c = fib(4)  </span>\n  \n<span class=\"hljs-comment\">/* 现在我们有这样的序列  \n   a  b  c  \n1, 1, 2, 3  \n*/</span>  \n</code></pre><p>以此类推，这样会比递归快很多，且没有重复计算。下边是完整代码：  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fibDynamicProgramming</span>(<span class=\"hljs-params\">n</span>) {  \n  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>  \n  <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">1</span>  \n  \n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">3</span>; i &lt;= n; i++) {  \n    <span class=\"hljs-keyword\">let</span> c = a + b  \n    a = b  \n    b = c  \n  }  \n  \n  <span class=\"hljs-keyword\">return</span> b  \n}  \n  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fibDynamicProgramming</span>(<span class=\"hljs-number\">77</span>))  \n</code></pre>","heading":[{"text":"斐波那契算法介绍","level":3,"id":"anchor-斐波那契算法介绍"},{"text":"算法实现","level":3,"id":"anchor-算法实现","children":[{"text":"普通递归","level":4,"id":"anchor-普通递归"},{"text":"缓存计算结果优化的方法","level":4,"id":"anchor-缓存计算结果优化的方法"},{"text":"自下而上的动态规划","level":4,"id":"anchor-自下而上的动态规划"}]}],"tags":["面试","javascript","算法"],"date":"2024-03-13","series":"javascript","title":"javascript的斐波那契算法实现","slug":"javascript-fibonacci","keywords":"javascript","description":"斐波那契,javascript,算法","lastmod":"2024-03-13","share":"true"}