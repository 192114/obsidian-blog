{"html":"<hr>\n<p>在实际开发中，我们应该按照几个基本原则进行分支管理：  </p>\n<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；  </p>\n<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；  </p>\n<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。  </p>\n<p>所以，团队合作的分支看起来就像这样：  </p>\n<p><img alt=\"git-team.png\" src=\"../../static/images/git-team.png\">  </p>\n<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。从分支历史上就可以看出分支信息  </p>\n<pre><code class=\"hljs language-Bash\">git merge --no-ff -m <span class=\"hljs-string\">\"merge with no-ff\"</span> dev  \nMerge made by the <span class=\"hljs-string\">'recursive'</span> strategy.  \n readme.txt | 1 +  \n 1 file changed, 1 insertion(+)  \n</code></pre><p><img alt=\"git-no-ff.png\" src=\"../../static/images/git-no-ff.png\">  </p>\n<h3 id=\"anchor-bug的处理\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-bug的处理\"><span class=\"octicon octicon-link\"></span></a>\n        bug的处理\n        </h3>\n<p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。  </p>\n<p>当前分支功能还没完成，这时候就需要git提供的<code>stash</code>，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。  </p>\n<pre><code class=\"hljs language-Bash\">git stash  \nSaved working directory and index state WIP on dev: f52c633 add merge  \n  \ngit checkout master <span class=\"hljs-comment\"># 切换需要改bug的分支  </span>\n  \ngit checkout -b issue-1 <span class=\"hljs-comment\"># 创建修改bug分支  </span>\n  \ngit commit -m <span class=\"hljs-string\">'fixed'</span> <span class=\"hljs-comment\"># 提交修改  </span>\n  \ngit switch master <span class=\"hljs-comment\"># 切换到主分支  </span>\n  \ngit merge --no-ff -m <span class=\"hljs-string\">'merge bug issue-1'</span> <span class=\"hljs-comment\"># 合并代码 （--no-ff 关闭fast-forward 生成一条merge记录）  </span>\n  \ngit switch dev <span class=\"hljs-comment\"># 切换到开发分支  </span>\n</code></pre><p>用<code>git stash list</code>命令看看  </p>\n<pre><code class=\"hljs language-Bash\">git stash list  \nstash@{0}: WIP on dev: f52c633 add merge  \n</code></pre><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；  </p>\n<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。  </p>\n<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。  </p>\n<p>Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支。  </p>\n<pre><code class=\"hljs language-Bash\">git branch  \n* dev  \n  master  \ngit cherry-pick 4c805e2  \n[master 1d4b803] fix bug 101  \n 1 file changed, 1 insertion(+), 1 deletion(-)  \n</code></pre><p><em><code>cherry-pick</code>和<code>git stash</code>步骤问题：</em><br>是回到dev分支后，先 git cherry-pick 4c805e2 再 git stash pop就可以了  </p>\n<h3 id=\"anchor-新特性开发\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-新特性开发\"><span class=\"octicon octicon-link\"></span></a>\n        新特性开发\n        </h3>\n<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。  </p>\n<p>创建新特性分支  </p>\n<pre><code class=\"hljs language-Bash\">git switch -c feature-vulcan  \nSwitched to a new branch <span class=\"hljs-string\">'feature-vulcan'</span>  \n</code></pre><p>提交分支  </p>\n<pre><code class=\"hljs language-Bash\">git add vulcan.py  \n  \ngit status  \nOn branch feature-vulcan  \nChanges to be committed:  \n  (use <span class=\"hljs-string\">\"git reset HEAD &lt;file&gt;...\"</span> to unstage)  \n  \n    new file:   vulcan.py  \n  \ngit commit -m <span class=\"hljs-string\">\"add feature vulcan\"</span>  \n[feature-vulcan 287773e] add feature vulcan  \n 1 file changed, 2 insertions(+)  \n create mode 100644 vulcan.py  \n</code></pre><p>切回开发分支  </p>\n<pre><code class=\"hljs language-Bash\">git switch dev  \n</code></pre><p>如果一切正常，可以使用<code>git merge feature-vulcan</code>合并，如果不需要该特性就可以<code>git branch -D feature-vulcan</code> 删除该分支  </p>\n<pre><code class=\"hljs language-Bash\">git branch -d feature-vulcan  \nerror: The branch <span class=\"hljs-string\">'feature-vulcan'</span> is not fully merged.  \nIf you are sure you want to delete it, run <span class=\"hljs-string\">'git branch -D feature-vulcan'</span>.  \n</code></pre><p><code>-D</code> 是强制删除，使用<code>-d</code>则是给出提示当前分支未合并，不能删除。  </p>\n<h3 id=\"anchor-团队协作\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-团队协作\"><span class=\"octicon octicon-link\"></span></a>\n        团队协作\n        </h3>\n<ul>\n<li>查看远程库信息，使用<code>git remote -v</code>；  </li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；  </li>\n<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；  </li>\n<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；  </li>\n<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；  </li>\n<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>\n</ul>\n<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。  </p>\n<p>要查看远程库的信息，用<code>git remote</code>：  </p>\n<pre><code class=\"hljs language-Bash\">git remote  \norigin  \n</code></pre><p>或者，用<code>git remote -v</code>显示更详细的信息：  </p>\n<pre><code class=\"hljs language-Bash\">git remote -v  \norigin  git@github.com:michaelliao/learngit.git (fetch)  \norigin  git@github.com:michaelliao/learngit.git (push)  \n</code></pre><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。  </p>\n<p>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。  </p>\n<pre><code class=\"hljs language-Bash\">git push origin dev <span class=\"hljs-comment\"># 推送到dev分支  </span>\n  \ngit push origin master <span class=\"hljs-comment\"># 推送到住分支  </span>\n</code></pre><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？  </p>\n<ul>\n<li><code>master</code>分支是主分支，因此要时刻与远程同步；  </li>\n<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；  </li>\n<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；  </li>\n<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>\n</ul>\n<h3 id=\"anchor-抓取分支\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-抓取分支\"><span class=\"octicon octicon-link\"></span></a>\n        抓取分支\n        </h3>\n<p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。  </p>\n<pre><code class=\"hljs language-Bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:michaelliao/learngit.git  \nCloning into <span class=\"hljs-string\">'learngit'</span>...  \nremote: Counting objects: 40, <span class=\"hljs-keyword\">done</span>.  \nremote: Compressing objects: 100% (21/21), <span class=\"hljs-keyword\">done</span>.  \nremote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0  \nReceiving objects: 100% (40/40), <span class=\"hljs-keyword\">done</span>.  \nResolving deltas: 100% (14/14), <span class=\"hljs-keyword\">done</span>.  \n</code></pre><p>从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支  </p>\n<p>要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：  </p>\n<pre><code class=\"hljs language-Bash\">git checkout -b dev origin/dev  \n</code></pre><p>现在，就可以在<code>dev</code>上继续修改，然后，把<code>dev</code>分支<code>push</code>到远程：  </p>\n<pre><code class=\"hljs language-Bash\">git push origin dev  \nCounting objects: 3, <span class=\"hljs-keyword\">done</span>.  \nDelta compression using up to 4 threads.  \nCompressing objects: 100% (2/2), <span class=\"hljs-keyword\">done</span>.  \nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, <span class=\"hljs-keyword\">done</span>.  \nTotal 3 (delta 0), reused 0 (delta 0)  \nTo github.com:michaelliao/learngit.git  \n   f52c633..7a5e5dd  dev -&gt; dev  \n</code></pre><p>多人协作的工作模式通常是这样：  </p>\n<ol>\n<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；  </li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；  </li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；  </li>\n<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>\n</ol>\n<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>\n","heading":[{"text":"bug的处理","level":3,"id":"anchor-bug的处理"},{"text":"新特性开发","level":3,"id":"anchor-新特性开发"},{"text":"团队协作","level":3,"id":"anchor-团队协作"},{"text":"抓取分支","level":3,"id":"anchor-抓取分支"}],"tags":["git"],"date":"2024-01-19","series":"其他","title":"Git分支策略","slug":"git-branch-strategy","keywords":"git branch strategy","description":"git用法，git 分支策略","lastmod":"","share":"true"}