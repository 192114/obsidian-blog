{"html":"<hr>\n<h3 id=\"anchor-什么是闭包\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-什么是闭包\"><span class=\"octicon octicon-link\"></span></a>\n        什么是闭包\n        </h3>\n<p><strong>闭包</strong>&nbsp;是指一个函数可以记住其外部变量并可以访问这些变量。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>){<span class=\"hljs-comment\">//func1引用了它外层的变量a，因此func成为了闭包  </span>\n    <span class=\"hljs-keyword\">let</span> a=<span class=\"hljs-string\">\"11\"</span>;  \n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<span class=\"hljs-comment\">//访问了外层函数func体内的变量a  </span>\n        <span class=\"hljs-keyword\">debugger</span>;<span class=\"hljs-comment\">//断点  </span>\n    }  \n    <span class=\"hljs-title function_\">func1</span>();  \n}  \n<span class=\"hljs-title function_\">func</span>();  \n</code></pre><p><img alt=\"1709777168158.jpg\" src=\"../../static/images/1709777168158.jpg\">  </p>\n<h3 id=\"anchor-为什么 Javascript 中所有的函数都是闭包\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-为什么 Javascript 中所有的函数都是闭包\"><span class=\"octicon octicon-link\"></span></a>\n        为什么 Javascript 中所有的函数都是闭包\n        </h3>\n<p>当访问一个变量时，首先会搜索内部的词法环境，然后搜索外部环境，以此类推，直到全局词法作用域。<br>如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。<br>关于词法作用域 <a href=\"https://zh.javascript.info/closure#ci-fa-huan-jing\">Lexical Environment</a><br>JavaScript 中的函数会自动通过隐藏的&nbsp;<code>[[Environment]]</code>&nbsp;属性记住创建它们的位置，所以它们都可以访问外部变量。  </p>\n<h3 id=\"anchor-经典小例子\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-经典小例子\"><span class=\"octicon octicon-link\"></span></a>\n        经典小例子\n        </h3>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) {  \n   <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) {  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i) <span class=\"hljs-comment\">//&gt;&gt; 6 6 6 6 6  </span>\n    }, i * <span class=\"hljs-number\">1000</span>);  \n}  \n</code></pre><p>本意是想每隔一秒输出“1 2 3 4 5”，但是却输出了“6 6 6 6 6 ”。原因是根据作用域链变量的查找机制，setTimeout 回调函数的 <code>i</code> 会引用全局变量的 <code>i</code>,当 for 循环完毕后，<code>i</code> 的值为 6，所以输出“6 6 6 6 6”。<br>下面是利用 IIFE 函数实现闭包，达成输出理想结果的例子：  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) {  \n  (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) {<span class=\"hljs-comment\">//包了一层IIFE形式的函数，这个函数是闭包  </span>\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-comment\">//函数体内的j引用了外层匿名函数的参数j  </span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(j); <span class=\"hljs-comment\">//&gt;&gt; 1 2 3 4 5  </span>\n    }, j * <span class=\"hljs-number\">1000</span>);  \n  })(i);  \n}  \n</code></pre><p>下面让我们用上面示例理解闭包的形成：  </p>\n<ul>\n<li>闭包肯定是一个函数  </li>\n<li>内层的函数需要引用上层作用域里的变量/参数，如上面的 IIFE 函数里的变量 <code>j</code> 引用上层作用域的 <code>j</code>，也就是 for 循环里的 <code>i</code></li>\n</ul>\n<h3 id=\"anchor-闭包的优缺点\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-闭包的优缺点\"><span class=\"octicon octicon-link\"></span></a>\n        闭包的优缺点\n        </h3>\n<ul>\n<li><strong>优点</strong>可以存储私有变量  </li>\n<li><strong>缺点</strong>闭包常驻与内存，容易造成内存泄漏</li>\n</ul>\n","heading":[{"text":"什么是闭包","level":3,"id":"anchor-什么是闭包"},{"text":"为什么 Javascript 中所有的函数都是闭包","level":3,"id":"anchor-为什么 Javascript 中所有的函数都是闭包"},{"text":"经典小例子","level":3,"id":"anchor-经典小例子"},{"text":"闭包的优缺点","level":3,"id":"anchor-闭包的优缺点"}],"tags":["面试","javascript"],"date":"2024-03-06","series":"javascript","title":"Javascript的闭包","slug":"js-closure","keywords":"javascript闭包","description":"面试,javascript,闭包,closuer","lastmod":"2024-03-07","share":"true"}