{"html":"<hr>\n<h3 id=\"anchor-区分 prototype、__proto__、原型\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-区分 prototype、__proto__、原型\"><span class=\"octicon octicon-link\"></span></a>\n        区分 prototype、__proto__、原型\n        </h3>\n<ul>\n<li><strong>原型 <code>[Prototype](Prototype.md)</code></strong>， 是对象的一个隐藏属性，它的值要是 <code>null</code> 要么是另一个<em>对象的引用</em></li>\n</ul>\n<blockquote>\n<p>当我们在对象里查找属性时，如果没有找到则会自动从 <code>原型</code>（[[Prototype]]）里找 ,在编程中称之为“原型继承”  </p>\n</blockquote>\n<ul>\n<li><strong><code>prototype</code> 是一个函数的属性，也是一个对象，它和原型没有绝对关系。</strong>（函数也是一个对象，每个对象都有原型，但是函数有 <code>prototype</code> 属性，其他对象没有）</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){};  \n<span class=\"hljs-keyword\">var</span> b=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];  \n  \n<span class=\"hljs-comment\">//函数才有prototype属性  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<span class=\"hljs-comment\">//&gt;&gt; function(){}  </span>\n<span class=\"hljs-comment\">//非函数，没有prototype属性  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<span class=\"hljs-comment\">//&gt;&gt; undefined  </span>\n</code></pre><blockquote>\n<p><code>F.prototype</code>&nbsp;属性仅在&nbsp;<code>new F</code>&nbsp;被调用时使用，它为新对象的&nbsp;<code>[[Prototype]]</code>&nbsp;赋值。<br>如果在创建之后，<code>F.prototype</code>&nbsp;属性有了变化（<code>F.prototype = &lt;another object&gt;</code>），那么通过&nbsp;<code>new F</code>&nbsp;创建的新对象也将随之拥有新的对象作为&nbsp;<code>[[Prototype]]</code>，但已经存在的对象将保持旧有的值。  </p>\n</blockquote>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Parent</span>(<span class=\"hljs-params\">name</span>) {  \n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;  \n}  \n  \n<span class=\"hljs-comment\">// 不建议直接修改prototype  </span>\n<span class=\"hljs-title class_\">Parent</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = {  \n  <span class=\"hljs-attr\">sayName</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> + <span class=\"hljs-string\">'A'</span>)  \n  }  \n}  \n  \n<span class=\"hljs-keyword\">const</span> child1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Parent</span>(<span class=\"hljs-string\">'child1'</span>)  \n  \n<span class=\"hljs-comment\">// 修改prototype  </span>\n<span class=\"hljs-title class_\">Parent</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = {  \n  <span class=\"hljs-attr\">sayName</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> + <span class=\"hljs-string\">'B'</span>)  \n  }  \n}  \n  \n<span class=\"hljs-keyword\">const</span> child2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Parent</span>(<span class=\"hljs-string\">'child2'</span>)  \n  \n<span class=\"hljs-comment\">// 第一次的值  </span>\nchild1.<span class=\"hljs-title function_\">sayName</span>() <span class=\"hljs-comment\">// &gt;&gt; child1A  </span>\n<span class=\"hljs-comment\">// 返回修改后的值  </span>\nchild2.<span class=\"hljs-title function_\">sayName</span>() <span class=\"hljs-comment\">// &gt;&gt; child2B  </span>\n</code></pre><ul>\n<li><em><em>一个对象的 * 原型（[[Prototype]]）</em> 就是它构造函数的 <code>prototype</code> 属性的值</em><em>，**<code>__proto__</code> 也是原型的代名词*</em></li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">S</span>(<span class=\"hljs-params\"></span>) {  \n&nbsp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">\"s\"</span>;  \n&nbsp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">18</span>;  \n&nbsp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n&nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>  \n&nbsp; }  \n}  \n<span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">S</span>()  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(s.<span class=\"hljs-property\">__proto__</span> === S.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// &gt;&gt; true  </span>\n</code></pre><p><img alt=\"1709870487859.jpg\" src=\"../../static/images/1709870487859.jpg\">  </p>\n<ul>\n<li>每个对象（实例）都有一个属性 __proto__，它指向构造函数（constructor）的 <code>prototype</code> 属性  </li>\n<li>对象的 <code>__proto__</code> 也有自己的 <code>__proto__</code>，层层向上，直到 <code>__proto__</code> 为 null。这种由原型层层链接起来的数据结构成为 <strong>原型链</strong>。因为 null 不再有原型，所以原型链的末端是 null。</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){};  \n<span class=\"hljs-keyword\">var</span> b=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];  \n  \n<span class=\"hljs-comment\">//a的构造函数是「Function函数」  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\">__proto__</span> == <span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<span class=\"hljs-comment\">//&gt;&gt; true  </span>\n<span class=\"hljs-comment\">//b的构造函数是「Array函数」  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b.<span class=\"hljs-property\">__proto__</span> == <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<span class=\"hljs-comment\">//&gt;&gt; true  </span>\n<span class=\"hljs-comment\">//因为「Function函数」和「Array函数」又都是对象，其构造函数  </span>\n<span class=\"hljs-comment\">//是「Object函数」，所以，a和b的原型的原型都是Object.prototype  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<span class=\"hljs-comment\">//&gt;&gt; true  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<span class=\"hljs-comment\">//&gt;&gt; true  </span>\n<span class=\"hljs-comment\">//Object作为顶级对象的构造函数，它实例的原型本身就不再有原型了，因此它原型  </span>\n<span class=\"hljs-comment\">//的__proto__属性为null  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>().<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">__proto__</span>);<span class=\"hljs-comment\">//&gt;&gt; null  </span>\n<span class=\"hljs-comment\">//也即Object类型对象，其原型（Object.prototype）的__proto__为null  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span>);<span class=\"hljs-comment\">//&gt;&gt; null  </span>\n</code></pre><p>三者的关系如下图所示：<br><img alt=\"1709874717824.jpg\" src=\"../../static/images/1709874717824.jpg\">  </p>\n<blockquote>\n<p><code>__proto__</code>&nbsp;是&nbsp;<code>[[Prototype]]</code>&nbsp;的因历史原因而留下来的 getter/setter<br><code>__proto__</code>&nbsp;属性有点过时了。现代编程语言建议我们应该使用函数&nbsp;<code>Object.getPrototypeOf/Object.setPrototypeOf</code>&nbsp;来取代&nbsp;<code>__proto__</code>&nbsp;去 get/set 原型  </p>\n</blockquote>\n<h3 id=\"anchor-原型的继承\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-原型的继承\"><span class=\"octicon octicon-link\"></span></a>\n        原型的继承\n        </h3>\n<ul>\n<li>通过 <code>__proto__</code> 赋值，<strong>EcmaScript6 规范，浏览器实现了它，但不推荐使用</strong></li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> obj = {  \n    <span class=\"hljs-title function_\">methodA</span>(<span class=\"hljs-params\"></span>) {  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'obj method A'</span>)  \n    }  \n}  \n<span class=\"hljs-keyword\">const</span> child = {}  \nchild.<span class=\"hljs-property\">__proto__</span> = obj  \nchild.<span class=\"hljs-title function_\">methodA</span>() <span class=\"hljs-comment\">// &gt;&gt; obj method A  </span>\n</code></pre><ul>\n<li><code>Object.getPrototypeOf</code>/<code>Reflect.getPrototypeOf</code> 和 <code>Object.setPrototypeOf</code>/<code>Reflect.setPrototypeOf</code>，<strong>速度比较慢，不推荐使用</strong></li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> obj = {  \n    <span class=\"hljs-title function_\">methodA</span>(<span class=\"hljs-params\"></span>) {  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'obj method A'</span>)  \n    }  \n}  \n<span class=\"hljs-keyword\">const</span> child = {}  \n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(child, obj)  \nchild.<span class=\"hljs-title function_\">methodA</span>() <span class=\"hljs-comment\">// &gt;&gt; obj method A  </span>\n</code></pre><ul>\n<li><code>Object.create()</code><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\">语法</a>，以现有对象为原型，创建新的对象</li>\n</ul>\n<blockquote>\n<p>语法<br>Object.create(proto)<br>Object.create(proto, propertiesObject)<br>返回值为指定原型对象和属性创建的新对象  </p>\n</blockquote>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> person = {  \n  <span class=\"hljs-attr\">isHuman</span>: <span class=\"hljs-literal\">false</span>,  \n  <span class=\"hljs-attr\">printIntroduction</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`My name is <span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.name}</span>. Am I human? <span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.isHuman}</span>`</span>);  \n  },  \n};  \n<span class=\"hljs-keyword\">const</span> me = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(person);  \nme.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">'Matthew'</span>; <span class=\"hljs-comment\">// \"name\" is a property set on \"me\", but not on \"person\"  </span>\nme.<span class=\"hljs-property\">isHuman</span> = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// Inherited properties can be overwritten  </span>\nme.<span class=\"hljs-title function_\">printIntroduction</span>();  \n<span class=\"hljs-comment\">// Expected output: \"My name is Matthew. Am I human? true\"  </span>\n</code></pre><blockquote>\n<p>修改已存在的对象的&nbsp;<code>[[Prototype]]</code> 是很慢的一个操作<br>用&nbsp;<code>Object.setPrototypeOf</code>&nbsp;或&nbsp;<code>obj.__proto__=</code>，\" 即时 \" 修改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。<br>而用 <code>Object.create()</code> 即在创建时就确定原型，故用其实现原型继承效率比较高  </p>\n</blockquote>\n<h3 id=\"anchor-原型链\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-原型链\"><span class=\"octicon octicon-link\"></span></a>\n        原型链\n        </h3>\n<p>当访问某个对象的方法或属性时，如果该对象上没有，JS 引擎就会遍历原型链上每个原型对象，在这些原型对象里查找，直到找到为止，如果最终没找到则报错。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> obj={  \n    <span class=\"hljs-title function_\">methodA</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"coffe\"</span>);  \n    }  \n}  \n<span class=\"hljs-keyword\">var</span> newObj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(obj);<span class=\"hljs-comment\">//以obj为原型创建一个新的对象  </span>\nnewObj.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">\"methodA\"</span>);<span class=\"hljs-comment\">//&gt;&gt; false  </span>\n</code></pre><p><code>hasOwnProperty</code> 在 <code>newObj</code> 上没有定义，它的原型 <code>obj</code> 也没有，最终在原型链上 <code>Object.prototype</code> 找到。如下图所示：<br><img alt=\"1709877258245.jpg\" src=\"../../static/images/1709877258245.jpg\">  </p>\n<h3 id=\"anchor-class（类）的 prototype 和 __proto__\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-class（类）的 prototype 和 __proto__\"><span class=\"octicon octicon-link\"></span></a>\n        class（类）的 prototype 和 __proto__\n        </h3>\n<p>关于 class（类）的使用见 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\">文档</a>  </p>\n<ul>\n<li>类的本身指向构造函数</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {  \n}  \n  \nA===A.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span>;<span class=\"hljs-comment\">//&gt;&gt; true  </span>\n</code></pre><ul>\n<li><strong>类的所有方法都定义在类的</strong><code>**prototype**</code><strong>属性上面</strong></li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>{  \n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-comment\">// ...  </span>\n  }  \n  \n  <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-comment\">// ...  </span>\n  }  \n  \n  <span class=\"hljs-title function_\">toValue</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-comment\">// ...  </span>\n  }  \n}  \n  \n<span class=\"hljs-comment\">// 等同于  </span>\nA.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = {  \n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {},  \n  <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) {},  \n  <span class=\"hljs-title function_\">toValue</span>(<span class=\"hljs-params\"></span>) {},  \n};  \n</code></pre><blockquote>\n<p>class 作为构造函数的语法糖，同时有 <code>prototype</code> 属性和 <code>__proto__</code> 属性，因此同时存在两条继承链  </p>\n<ol>\n<li>子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类  </li>\n<li>子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 <code>prototype</code> 属性</li>\n</ol>\n</blockquote>\n","heading":[{"text":"区分 prototype、__proto__、原型","level":3,"id":"anchor-区分 prototype、__proto__、原型"},{"text":"原型的继承","level":3,"id":"anchor-原型的继承"},{"text":"原型链","level":3,"id":"anchor-原型链"},{"text":"class（类）的 prototype 和 __proto__","level":3,"id":"anchor-class（类）的 prototype 和 __proto__"}],"tags":["面试","javascript"],"date":"2024-03-08","series":"javascript","title":"原型、prototype","slug":"js-prototype-intro","keywords":"javascript","description":"面试，原型，prototype，继承，class，extends，原型链","lastmod":"2024-03-11","share":"true"}