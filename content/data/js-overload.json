{"html":"<hr>\n<p>重载是面向对象编程语言（如JAVA、C#）里的特性，Javascript语言并不支持该特性。  </p>\n<blockquote>\n<p>重载（overload）是函数的名称一样，但是通过传入参数的个数不一样，调用不同的逻辑或返回不同的结果。  </p>\n</blockquote>\n<h4 id=\"anchor-实现\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-实现\"><span class=\"octicon octicon-link\"></span></a>\n        实现\n        </h4>\n<p>下面的方法是Jquery的作者John Resig实现的一个巧妙的思路：  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">/**  \n&nbsp;* 函数重载方法  \n&nbsp;* <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} name  \n&nbsp;* <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">number</span>} age  \n&nbsp;* <span class=\"hljs-doctag\">@returns</span>  \n&nbsp;*/</span>  \n  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">overload</span>(<span class=\"hljs-params\">map, name, fn</span>) {  \n&nbsp; <span class=\"hljs-keyword\">const</span> previousHandler = map[name]; <span class=\"hljs-comment\">// 保存之前的函数 闭包 可以查找之前的方法  </span>\n&nbsp; map[name] = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n&nbsp; &nbsp; <span class=\"hljs-comment\">// fn.length 是overload调用时候注册的函数的参数个数 （闭包）  </span>\n&nbsp; &nbsp; <span class=\"hljs-comment\">// arguments.length 是函数执行时候传入的参数个数  </span>\n&nbsp; &nbsp; <span class=\"hljs-keyword\">if</span> (fn.<span class=\"hljs-property\">length</span> === <span class=\"hljs-variable language_\">arguments</span>.<span class=\"hljs-property\">length</span>) {  \n&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">arguments</span>);  \n&nbsp; &nbsp; } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> previousHandler === <span class=\"hljs-string\">'function'</span>) {  \n&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 如果参数个数不匹配 则调用之前注册的方法  </span>\n&nbsp; &nbsp; &nbsp; <span class=\"hljs-comment\">// 由于是闭包，所以可以查找之前的方法 一直递归调用 直到找到符合条件的方法  </span>\n&nbsp; &nbsp; &nbsp; <span class=\"hljs-keyword\">return</span> previousHandler.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">arguments</span>);  \n&nbsp; &nbsp; }  \n&nbsp; }  \n}  \n  \n<span class=\"hljs-keyword\">const</span> obj = {};  \n  \n<span class=\"hljs-comment\">// 不传参数时  </span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn0</span>(<span class=\"hljs-params\"></span>) {  \n&nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"no param\"</span>;  \n}  \n  \n<span class=\"hljs-comment\">// 传1个参数  </span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn1</span>(<span class=\"hljs-params\">param1</span>) {  \n&nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"1 param:\"</span> + param1;  \n}  \n  \n<span class=\"hljs-comment\">// 传两个参数时，返回param1和param2都匹配的name  </span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-params\">param1, param2</span>) {  \n&nbsp; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"2 param:\"</span> + [param1, param2];  \n}  \n  \n<span class=\"hljs-title function_\">overload</span>(obj, <span class=\"hljs-string\">\"fn\"</span>, fn0);<span class=\"hljs-comment\">//给obj添加第1个重载的函数  </span>\n  \n<span class=\"hljs-title function_\">overload</span>(obj, <span class=\"hljs-string\">\"fn\"</span>, fn1);<span class=\"hljs-comment\">//给obj添加第2个重载的函数  </span>\n  \n<span class=\"hljs-title function_\">overload</span>(obj, <span class=\"hljs-string\">\"fn\"</span>, fn2);<span class=\"hljs-comment\">//给obj添加第3个重载的函数  </span>\n  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">fn</span>());<span class=\"hljs-comment\">//&gt;&gt; no param  </span>\n  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-number\">1</span>));<span class=\"hljs-comment\">//&gt;&gt; 1 param:1  </span>\n  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));<span class=\"hljs-comment\">//&gt;&gt; 2 param:1,2  </span>\n</code></pre><h4 id=\"anchor-解析\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-解析\"><span class=\"octicon octicon-link\"></span></a>\n        解析\n        </h4>\n<p>主要是利用了闭包（<a href=\"./js-closure\">closure</a>）,每次调用<code>overload</code>方法，都会产生一个<code>previousHandler</code>方法，存储上一个方法，形成闭包，使之前的方法都存在与内存中。<br>下面用一张图来清晰的展示：<br><img alt=\"overload.jpg\" src=\"../../static/images/overload.jpg\">  </p>\n<ul>\n<li><code>fn.length</code> 表示函数的形式参数的数量，<code>arguments</code>表示实际传入参数的数量  </li>\n<li>判断实参和形参数量相同表示命中需要执行的函数直接执行  </li>\n<li>如果没用命中则执行<code>previousHandler</code>，依次查找直到找到匹配函数后执行</li>\n</ul>\n<p>此时函数中的<code>this</code>是外层调用的对象<code>obj</code>。  </p>\n<h4 id=\"anchor-总结\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-总结\"><span class=\"octicon octicon-link\"></span></a>\n        总结\n        </h4>\n<p>虽然JavaScript上没有真正意义上的重载，但是却很常见，比如<code>splice</code>，一个参数是删除，两个参数是删除部分，三个参数是删除之后在新增。同样的还有<code>arseInt</code>等方法。<br>重载的好处是，功能相近的函数可以通过一个函数来实现，减少函数定义的数量。</p>\n","heading":[{"text":"实现","level":4,"id":"anchor-实现"},{"text":"解析","level":4,"id":"anchor-解析"},{"text":"总结","level":4,"id":"anchor-总结"}],"tags":["javascript","面试"],"date":"2024-03-05","series":"javascript","title":"js-overload","slug":"js-overload","keywords":"javascript函数重载","description":"面试,js函数重载,Jquery作者实现","lastmod":"2024-03-07","share":"true"}