{"html":"<hr>\n<p><code>this</code>指向当前代码运行时所处的上下文环境（context）。<code>this</code>指向的是<strong>函数调用位置</strong>的对象，也就是<strong>调用该函数的对象</strong>。<code>this</code>就是一个变量存储着调用该函数的对象的值。  </p>\n<h3 id=\"anchor-说明\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-说明\"><span class=\"octicon octicon-link\"></span></a>\n        说明\n        </h3>\n<ul>\n<li><code>this</code>的指向是在<strong>函数被调用的时候确定的</strong>，也就是执行上下文时确定的  </li>\n<li><code>this</code>与函数的声明位置无关，只取决于调用位置（由谁，在什么地方调用）  </li>\n<li>在执行上下文时候调用，所以<code>this</code>不可更改</li>\n</ul>\n<h3 id=\"anchor-指向规则\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-指向规则\"><span class=\"octicon octicon-link\"></span></a>\n        指向规则\n        </h3>\n<h4 id=\"anchor-1.默认指向\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-1.默认指向\"><span class=\"octicon octicon-link\"></span></a>\n        1.默认指向\n        </h4>\n<p>独立的函数调用，this会指向全局对象window。这样取决于是否是在严格模式下，如果在严格模式下，this的指向是undefined。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a1</span>)  \n}  \n  \n<span class=\"hljs-keyword\">var</span> a1 = <span class=\"hljs-string\">'1'</span>  \n  \n<span class=\"hljs-title function_\">func1</span>() <span class=\"hljs-comment\">// '1' 此时this指向的是window  </span>\n  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func2</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-string\">'use strict'</span>  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a1</span>)  \n}  \n  \n<span class=\"hljs-title function_\">func2</span>() <span class=\"hljs-comment\">// Uncaught TypeError TypeError: Cannot read properties of undefined (reading 'a1')  </span>\n</code></pre><p>如果是在<code>setTimeout</code>和<code>setInterval</code>中使用，this会指向window对象。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> num = <span class=\"hljs-number\">0</span>;  \n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Obj</span> {  \n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">num</span>){  \n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span> = num;  \n    }  \n    <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span>);  \n    }  \n    <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"setTimeout:\"</span>+<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span>);  \n        }, <span class=\"hljs-number\">1000</span>)  \n    }  \n    <span class=\"hljs-title function_\">func2</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span>);  \n        }, <span class=\"hljs-number\">2000</span>)  \n    }  \n}  \n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Obj</span>(<span class=\"hljs-number\">1</span>);  \nobj.<span class=\"hljs-title function_\">func</span>();<span class=\"hljs-comment\">//&gt;&gt; 1　             输出的是obj.num  </span>\nobj.<span class=\"hljs-title function_\">func1</span>()<span class=\"hljs-comment\">//&gt;&gt; setTimeout:0　  输出的是window.num  </span>\nobj.<span class=\"hljs-title function_\">func2</span>()<span class=\"hljs-comment\">//&gt;&gt; 0 0 0 0 ……　    输出的是window.num  </span>\n</code></pre><h4 id=\"anchor-2. 隐式指向\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-2. 隐式指向\"><span class=\"octicon octicon-link\"></span></a>\n        2. 隐式指向\n        </h4>\n<p>函数体内this指向是由调用位置的调用者决定的。<strong>调用者调用的函数为某一个对象的方法，调用时内部的this指向该对象。</strong>  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>)  \n}  \n  \n<span class=\"hljs-keyword\">var</span> obj = {  \n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,  \n    <span class=\"hljs-attr\">func</span>: func1,  \n}  \n  \nobj.<span class=\"hljs-title function_\">func</span>() <span class=\"hljs-comment\">// &gt;&gt; 1  </span>\n<span class=\"hljs-comment\">// 此时的this指向的是调用者obj  </span>\n</code></pre><p>如果多层调用，<strong>则由最顶层或着说是最后一层调用影响。也就是离的最近的调用者。</strong>  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>);  \n}  \n  \n<span class=\"hljs-keyword\">var</span> obj2 = {  \n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">\"1891\"</span>,  \n  <span class=\"hljs-attr\">func</span>: func  \n};  \n  \n<span class=\"hljs-keyword\">var</span> obj1 = {  \n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">\"coffe\"</span>,  \n  <span class=\"hljs-attr\">obj2</span>: obj2  \n};  \n  \n<span class=\"hljs-comment\">//此时的 this 指向 obj2 对象，因为obj2离得近！  </span>\nobj1.<span class=\"hljs-property\">obj2</span>.<span class=\"hljs-title function_\">func</span>(); <span class=\"hljs-comment\">//&gt;&gt; 1891  </span>\n</code></pre><p>还有一种<strong>隐式丢失</strong>：  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> );  \n}  \n  \n<span class=\"hljs-keyword\">var</span> obj = {  \n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">\"coffe1891\"</span>,  \n    <span class=\"hljs-attr\">func</span>: func  \n};  \n  \n<span class=\"hljs-keyword\">var</span> bar = obj.<span class=\"hljs-property\">func</span>; <span class=\"hljs-comment\">// 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实  </span>\n                    <span class=\"hljs-comment\">// 都指向内存中的函数func本身。  </span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">\"oops, global\"</span>; <span class=\"hljs-comment\">// a 是全局对象window的属性，也是全局变量  </span>\n<span class=\"hljs-title function_\">bar</span>(); <span class=\"hljs-comment\">//&gt;&gt; oops, global  </span>\n  \n<span class=\"hljs-comment\">// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，  </span>\n<span class=\"hljs-comment\">// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,  </span>\n<span class=\"hljs-comment\">// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a）  </span>\n</code></pre><h4 id=\"anchor-3.显示调用\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-3.显示调用\"><span class=\"octicon octicon-link\"></span></a>\n        3.显示调用\n        </h4>\n<p>由Javascript内置对象Function的三个原型方法<code>call</code>、<code>apply</code>、<code>bind</code>可以显示的修改this的指向。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">'1'</span>  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>)  \n}  \n<span class=\"hljs-keyword\">var</span> obj = {  \n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">'2'</span>  \n}  \nfunc.<span class=\"hljs-title function_\">apply</span>(obj) <span class=\"hljs-comment\">// '2' 调用时强制把this指向改成obj  </span>\n  \n</code></pre><p>使用<code>bind</code>改变setInterval和setTimeout的this的指向：  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> num = <span class=\"hljs-number\">0</span>;  \n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Obj</span> {  \n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">num</span>){  \n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span> = num;  \n    }  \n    <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span>);  \n    }  \n    <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"setTimeout:\"</span>+<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span>);  \n        }.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>), <span class=\"hljs-number\">1000</span>);<span class=\"hljs-comment\">//bind  </span>\n    }  \n    <span class=\"hljs-title function_\">func2</span>(<span class=\"hljs-params\"></span>){  \n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {  \n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">num</span>);  \n        }.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-variable language_\">this</span>), <span class=\"hljs-number\">2000</span>);<span class=\"hljs-comment\">//bind  </span>\n    }  \n}  \n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Obj</span>(<span class=\"hljs-number\">1</span>);  \nobj.<span class=\"hljs-title function_\">func</span>();<span class=\"hljs-comment\">//&gt;&gt; 1　             输出的是obj.num  </span>\nobj.<span class=\"hljs-title function_\">func1</span>()<span class=\"hljs-comment\">//&gt;&gt; setTimeout:1　  输出的是obj.num  </span>\nobj.<span class=\"hljs-title function_\">func2</span>()<span class=\"hljs-comment\">//&gt;&gt; 1 1 1 1 ……　    输出的是obj.num  </span>\n</code></pre><h4 id=\"anchor-4. new 操作符的指向\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-4. new 操作符的指向\"><span class=\"octicon octicon-link\"></span></a>\n        4. new 操作符的指向\n        </h4>\n<p><strong>构造函数</strong>指的是<strong>用new操作符调用的函数</strong>。使用<code>new</code>调用函数或着说是发生构造函数调用时，会执行如下操作：  </p>\n<ol>\n<li>创建（构造）一个全新的对象  </li>\n<li>将构造函数的作用域赋值给新对象（this指向这个新对象）  </li>\n<li>执行构造函数中的代码（为新对象添加属性方法等）  </li>\n<li>如果函数没有返回值则返回这个新对象</li>\n</ol>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Func</span>(<span class=\"hljs-params\">a</span>) {  \n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> = a  \n}  \n  \n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Func</span>(<span class=\"hljs-string\">'11'</span>)  \n  \n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// '11'  调用 new Fuc(..)时 将新对象绑定到了Func的this上  </span>\n</code></pre><h3 id=\"anchor-如果判断this的指向\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-如果判断this的指向\"><span class=\"octicon octicon-link\"></span></a>\n        如果判断this的指向\n        </h3>\n<p>可以根据如下顺序判断<code>this</code>的指向问题。  </p>\n<h4 id=\"anchor-1. 函数在new中被调用\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-1. 函数在new中被调用\"><span class=\"octicon octicon-link\"></span></a>\n        1. 函数在new中被调用\n        </h4>\n<p><strong><code>this</code>指向到新创建的对象</strong>  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\">name</span>) {  \n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;  \n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>;  \n  };  \n}  \n  \n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-string\">\"coffe\"</span>); <span class=\"hljs-comment\">//this会指向obj  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">getName</span>()); <span class=\"hljs-comment\">//&gt;&gt; coffe  </span>\n</code></pre><h4 id=\"anchor-2.函数通过<code>call</code>、<code>apply</code>、<code>bind</code>显示调用\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-2.函数通过<code>call</code>、<code>apply</code>、<code>bind</code>显示调用\"><span class=\"octicon octicon-link\"></span></a>\n        2.函数通过<code>call</code>、<code>apply</code>、<code>bind</code>显示调用\n        </h4>\n<p><strong><code>this</code>指向call、bind、apply方法的第一个参数执行的对象</strong>  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> obj1 = {  \n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"coffe\"</span>  \n};  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">//这里的this本来指向window  </span>\n}  \n<span class=\"hljs-keyword\">var</span> str = func.<span class=\"hljs-title function_\">call</span>(obj1); <span class=\"hljs-comment\">//改变了func函数里面this的指向，指向obj1  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str); <span class=\"hljs-comment\">//&gt;&gt; coffe  </span>\n</code></pre><h4 id=\"anchor-3.函数作为某个对象的方法隐式调用\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-3.函数作为某个对象的方法隐式调用\"><span class=\"octicon octicon-link\"></span></a>\n        3.函数作为某个对象的方法隐式调用\n        </h4>\n<p><strong><code>this</code>指向的是调用者，也就是那个调用对象</strong>  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> obj1 = {  \n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"coffe\"</span>,  \n  <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">//指向obj1  </span>\n  }  \n};  \n  \n<span class=\"hljs-comment\">//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj1.<span class=\"hljs-title function_\">func</span>()); <span class=\"hljs-comment\">//&gt;&gt; coffe  </span>\n</code></pre><h4 id=\"anchor-4.以上都不是则默认指向\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-4.以上都不是则默认指向\"><span class=\"octicon octicon-link\"></span></a>\n        4.以上都不是则默认指向\n        </h4>\n<p><strong>严格模式下指向到undefined，否则指向到全局对象。</strong>  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">\"coffe\"</span>; <span class=\"hljs-comment\">//为全局对象window添加一个属性a  </span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n  <span class=\"hljs-string\">\"use strict\"</span>;<span class=\"hljs-comment\">//开启严格模式  </span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;  \n}  \n  \n<span class=\"hljs-comment\">//严格模式下，this指向undefined  </span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func</span>()); <span class=\"hljs-comment\">//&gt;&gt; TypeError  </span>\n</code></pre><h3 id=\"anchor-例外情况\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-例外情况\"><span class=\"octicon octicon-link\"></span></a>\n        例外情况\n        </h3>\n<h4 id=\"anchor-1. 被忽略的this\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-1. 被忽略的this\"><span class=\"octicon octicon-link\"></span></a>\n        1. 被忽略的this\n        </h4>\n<p><code>null</code>或着<code>undefined</code>作为<code>this</code>的指向，如作为<code>call</code>、<code>apply</code>、<code>bind</code>第一个参数传进去，则会被忽略，使用默认的指向规则。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>);  \n}  \n  \n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;  \nfunc.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">//&gt;&gt; 2  </span>\n                 <span class=\"hljs-comment\">//this指向了window  </span>\n</code></pre><h4 id=\"anchor-2.隐式指向之隐式丢失\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-2.隐式指向之隐式丢失\"><span class=\"octicon octicon-link\"></span></a>\n        2.隐式指向之隐式丢失\n        </h4>\n<p><strong>隐式丢失最容易在赋值时发生</strong>；隐式丢失发生时，调用这个函数会应用<strong>默认指向规则</strong>。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>);  \n}  \n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;  \n<span class=\"hljs-keyword\">var</span> o = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">func</span>: func };  \n<span class=\"hljs-keyword\">var</span> p = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">4</span> };  \no.<span class=\"hljs-title function_\">func</span>(); <span class=\"hljs-comment\">//&gt;&gt; 3  </span>\n(p.<span class=\"hljs-property\">func</span> = o.<span class=\"hljs-property\">func</span>)(); <span class=\"hljs-comment\">//&gt;&gt; 2  </span>\n<span class=\"hljs-comment\">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用  </span>\n<span class=\"hljs-comment\">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()  </span>\n</code></pre><h4 id=\"anchor-3.箭头函数\">\n        <a aria-hidden=\"true\" class=\"anchor\" href=\"#anchor-3.箭头函数\"><span class=\"octicon octicon-link\"></span></a>\n        3.箭头函数\n        </h4>\n<p>箭头函数不遵守<code>this</code>的四种指向规则，而是<strong>根据函数定义时的作用域来决定</strong> <code>this</code> <strong>的指向</strong>。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。  </p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\"></span>) {  \n  <span class=\"hljs-comment\">// 返回一个箭头函数  </span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =&gt;</span> {  \n    <span class=\"hljs-comment\">//this 继承自 func()  </span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>);  \n  };  \n}  \n<span class=\"hljs-keyword\">var</span> obj1 = {  \n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">2</span>  \n};  \n<span class=\"hljs-keyword\">var</span> obj2 = {  \n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>  \n};  \n  \n<span class=\"hljs-keyword\">var</span> bar = func.<span class=\"hljs-title function_\">call</span>(obj1);  \nbar.<span class=\"hljs-title function_\">call</span>(obj2); <span class=\"hljs-comment\">//&gt;&gt; 2         不是 3 ！  </span>\n  \n<span class=\"hljs-comment\">// func() 内部创建的箭头函数会捕获调用时 func() 的 this。  </span>\n<span class=\"hljs-comment\">// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，  </span>\n<span class=\"hljs-comment\">// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）  </span>\n</code></pre><p>所以也可以认为箭头函数没有自己的this，通常情况下，this只用在函数运行之后才能确定，但是箭头函数的this是在函数定义的时候就确定了，且运行时无法修改即相当一个固定的变量。</p>\n","heading":[{"text":"说明","level":3,"id":"anchor-说明"},{"text":"指向规则","level":3,"id":"anchor-指向规则","children":[{"text":"1.默认指向","level":4,"id":"anchor-1.默认指向"},{"text":"2. 隐式指向","level":4,"id":"anchor-2. 隐式指向"},{"text":"3.显示调用","level":4,"id":"anchor-3.显示调用"},{"text":"4. new 操作符的指向","level":4,"id":"anchor-4. new 操作符的指向"}]},{"text":"如果判断this的指向","level":3,"id":"anchor-如果判断this的指向","children":[{"text":"1. 函数在new中被调用","level":4,"id":"anchor-1. 函数在new中被调用"},{"text":"2.函数通过<code>call</code>、<code>apply</code>、<code>bind</code>显示调用","level":4,"id":"anchor-2.函数通过<code>call</code>、<code>apply</code>、<code>bind</code>显示调用"},{"text":"3.函数作为某个对象的方法隐式调用","level":4,"id":"anchor-3.函数作为某个对象的方法隐式调用"},{"text":"4.以上都不是则默认指向","level":4,"id":"anchor-4.以上都不是则默认指向"}]},{"text":"例外情况","level":3,"id":"anchor-例外情况","children":[{"text":"1. 被忽略的this","level":4,"id":"anchor-1. 被忽略的this"},{"text":"2.隐式指向之隐式丢失","level":4,"id":"anchor-2.隐式指向之隐式丢失"},{"text":"3.箭头函数","level":4,"id":"anchor-3.箭头函数"}]}],"tags":["面试","javascript"],"date":"2024-03-06","series":"javascript","title":"Javascript的this","slug":"js-this","keywords":"javascript this","description":"面试,javascript,this","lastmod":"2024-03-06","share":"true"}